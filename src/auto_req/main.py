from pathlib import Path
import sys
from typing import Set, Optional
from datetime import datetime
from importlib.metadata import version, distributions, PackageNotFoundError

FILE_FLAGS = frozenset([
    '-r', '--requirement',
    '-c', '--constraint',
    '--no-deps',
    '--target',
    '--editable', '-e'
])

class AutoReq:
    """
    Automatically manages your requirements.txt file by tracking pip installations.
    Updates package versions and maintains a clean, sorted list of dependencies.
    """
    
    def __init__(self, project_dir: Optional[str] = None):
        """Set up AutoReq in the current directory or a specified project path"""
        self.project_dir = Path(project_dir) if project_dir else Path.cwd()
        self.req_file = self.project_dir / 'requirements.txt'
    
    def _ensure_file_exists(self) -> None:
        """Ensure requirements.txt exists, create if it doesn't"""
        if not self.req_file.parent.exists():
            self.req_file.parent.mkdir(parents=True, exist_ok=True)
        if not self.req_file.exists():
            self._write_requirements(set(), skip_ensure=True)  # Add skip_ensure parameter
    
    def _read_requirements(self) -> Set[str]:
        """Load the current requirements.txt file, skipping comments"""
        self._ensure_file_exists()
        packages = set()
        with open(self.req_file) as f:
            packages = {
                line.strip() 
                for line in f 
                if line.strip() and not line.startswith('#')
            }
        return packages
    
    def _write_requirements(self, packages: Set[str], skip_ensure: bool = False) -> None:
        """Save the updated package list to requirements.txt"""
        try:
            if not skip_ensure:
                self._ensure_file_exists()
            with open(self.req_file, 'w') as f:
                f.write(f"# Generated by AutoReq on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("# Do not edit this file manually\n\n")
                for pkg in sorted(packages):
                    f.write(f"{pkg}\n")
            
            if not self.req_file.exists():
                raise FileNotFoundError(f"Failed to create {self.req_file}")
                        
        except Exception as e:
            print(f"Error writing requirements file: {e}", file=sys.stderr)
            raise
    
    def _should_process_command(self) -> bool:
        """Check if this pip command needs our attention"""
        args = sys.argv[1:]
        if not args:
            return False
        return not any(flag in args for flag in FILE_FLAGS)
    
    def _is_valid_package(self, package: str) -> bool:
        """Make sure this is a standard PyPI package (not a URL or local path)"""
        return (
            package 
            and not package.startswith('-') 
            and not package.startswith('.')
            and not package.startswith('git+')
            and not package.startswith('http')
        )
    
    def update_requirements(self, package: str, remove: bool = False) -> None:
        """
        Add or remove a package from requirements.txt.
        
        Args:
            package: Name of the package (with optional version specifiers)
            remove: True to remove the package, False to add it
        """
        try:
            if remove:
                packages = self._read_requirements()
                base_name = package.split('==')[0].split('>=')[0].split('<=')[0]
                
                new_packages = {
                    pkg for pkg in packages 
                    if not pkg.split('==')[0].split('>=')[0].split('<=')[0] == base_name
                }
                
                if new_packages != packages:
                    self._write_requirements(new_packages)
                return
            
            if not self._should_process_command():
                return
            
            if not self._is_valid_package(package):
                return
            
            packages = self._read_requirements()
            base_name = package.split('==')[0].split('>=')[0].split('<=')[0]
            
            # Ensure auto-req is added to requirements.txt
            if base_name == 'auto-req':
                package = f"auto-req=={version('auto-req')}"
            
            packages = {
                pkg for pkg in packages 
                if not pkg.split('==')[0].split('>=')[0].split('<=')[0] == base_name
            }
            
            if any(op in package for op in ['==', '>=', '<=']):
                clean_package = package
            else:
                try:
                    pkg_version = version(package)
                    clean_package = f"{package}=={pkg_version}"
                except PackageNotFoundError:
                    clean_package = package
            
            packages.add(clean_package)
            self._write_requirements(packages)
            
        except Exception as e:
            print(f"Warning: Could not update requirements: {e}", file=sys.stderr)

    def post_install(self):
        """Run after auto-req installation to capture existing packages"""
        try:
            existing_packages = {}
            if self.req_file.exists():
                with open(self.req_file) as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            name = line.split('==')[0].split('>=')[0].split('<=')[0]
                            existing_packages[name] = line
            
            installed = {dist.metadata['Name']: dist.version for dist in distributions()}
            
            final_packages = set(existing_packages.values())
            for name, ver in installed.items():
                if name not in existing_packages:
                    final_packages.add(f"{name}=={ver}")
            
            # Ensure auto-req is included
            auto_req_ver = version('auto-req')
            final_packages = {pkg for pkg in final_packages if not pkg.startswith('auto-req')}
            final_packages.add(f"auto-req=={auto_req_ver}")
            
            # Write updated requirements file
            self._write_requirements(final_packages)
            
        except Exception as e:
            print(f"Warning: Could not update requirements.txt during installation: {e}", 
                  file=sys.stderr)
