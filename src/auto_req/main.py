from pathlib import Path
import sys
from typing import Set, Optional
from datetime import datetime
from importlib.metadata import version, PackageNotFoundError

FILE_FLAGS = frozenset([
    '-r', '--requirement',
    '-c', '--constraint',
    '--no-deps',
    '--target',
    '--editable', '-e'
])

class AutoReq:
    def __init__(self, project_dir: Optional[str] = None):
        """Initialize Auto-Req with optional project directory"""
        self.project_dir = Path(project_dir) if project_dir else Path.cwd()
        self.req_file = self.project_dir / 'requirements.txt'
        
    def _read_requirements(self) -> Set[str]:
        """Read and parse requirements file"""
        packages = set()
        if self.req_file.exists():
            with open(self.req_file) as f:
                packages = {
                    line.strip() 
                    for line in f 
                    if line.strip() and not line.startswith('#')
                }
        return packages
    
    def _write_requirements(self, packages: Set[str]) -> None:
        """Write packages to requirements file"""
        with open(self.req_file, 'w') as f:
            f.write(f"# Generated by PipAuto on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write("# Do not edit this file manually\n\n")
            for pkg in sorted(packages):
                f.write(f"{pkg}\n")
    
    def _should_process_command(self) -> bool:
        """Check if the current pip command should be processed"""
        args = sys.argv[1:]
        if not args:
            return False
        return not any(flag in args for flag in FILE_FLAGS)
    
    def _is_valid_package(self, package: str) -> bool:
        """Check if package name is valid"""
        return (
            package 
            and not package.startswith('-') 
            and not package.startswith('.')
            and not package.startswith('git+')
            and not package.startswith('http')
        )
    
    def update_requirements(self, package: str, remove: bool = False) -> None:
        """Update requirements file with package"""
        try:
            if not self._should_process_command():
                return
                
            if not self._is_valid_package(package):
                return
            
            packages = self._read_requirements()
            
            if remove:
                # For removal, we need to match any version of the package
                packages = {p for p in packages if not p.startswith(package)}
            else:
                # Keep the version specifier if present
                if any(op in package for op in ['==', '>=', '<=']):
                    clean_package = package
                else:
                    # If no version specified, get installed version
                    try:
                        pkg_version = version(package)
                        clean_package = f"{package}=={pkg_version}"
                    except PackageNotFoundError:
                        clean_package = package
                
                packages.add(clean_package)
            
            self._write_requirements(packages)
            
        except Exception as e:
            print(f"Warning: Could not update requirements: {e}", file=sys.stderr)
