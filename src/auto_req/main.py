from pathlib import Path
import sys
from typing import Set, Optional
from datetime import datetime
from importlib.metadata import version, PackageNotFoundError

FILE_FLAGS = frozenset([
    '-r', '--requirement',
    '-c', '--constraint',
    '--no-deps',
    '--target',
    '--editable', '-e'
])

class AutoReq:
    """
    Automatically manages your requirements.txt file by tracking pip installations.
    Updates package versions and maintains a clean, sorted list of dependencies.
    """
    
    def __init__(self, project_dir: Optional[str] = None):
        """Set up AutoReq in the current directory or a specified project path"""
        self.project_dir = Path(project_dir) if project_dir else Path.cwd()
        self.req_file = self.project_dir / 'requirements.txt'
        
    def _read_requirements(self) -> Set[str]:
        """Load the current requirements.txt file, skipping comments"""
        packages = set()
        if self.req_file.exists():
            with open(self.req_file) as f:
                packages = {
                    line.strip() 
                    for line in f 
                    if line.strip() and not line.startswith('#')
                }
        return packages
    
    def _write_requirements(self, packages: Set[str]) -> None:
        """Save the updated package list to requirements.txt"""
        try:
            with open(self.req_file, 'w') as f:
                f.write(f"# Generated by AutoReq on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("# Do not edit this file manually\n\n")
                for pkg in sorted(packages):
                    f.write(f"{pkg}\n")
            
            if not self.req_file.exists():
                raise FileNotFoundError(f"Failed to create {self.req_file}")
            
            print(f"Requirements file updated: {self.req_file}")
            
        except Exception as e:
            print(f"Error writing requirements file: {e}", file=sys.stderr)
            raise
    
    def _should_process_command(self) -> bool:
        """Check if this pip command needs our attention"""
        args = sys.argv[1:]
        if not args:
            return False
        return not any(flag in args for flag in FILE_FLAGS)
    
    def _is_valid_package(self, package: str) -> bool:
        """Make sure this is a standard PyPI package (not a URL or local path)"""
        return (
            package 
            and not package.startswith('-') 
            and not package.startswith('.')
            and not package.startswith('git+')
            and not package.startswith('http')
        )
    
    def update_requirements(self, package: str, remove: bool = False) -> None:
        """
        Add or remove a package from requirements.txt.
        
        Args:
            package: Name of the package (with optional version specifiers)
            remove: True to remove the package, False to add it
        """
        try:
            if remove:
                packages = self._read_requirements()
                base_name = package.split('==')[0].split('>=')[0].split('<=')[0]
                
                new_packages = {
                    pkg for pkg in packages 
                    if not pkg.split('==')[0].split('>=')[0].split('<=')[0] == base_name
                }
                
                if new_packages != packages:
                    self._write_requirements(new_packages)
                return
            
            if not self._should_process_command():
                return
            
            if not self._is_valid_package(package):
                return
            
            packages = self._read_requirements()
            base_name = package.split('==')[0].split('>=')[0].split('<=')[0]
            
            # Ensure auto-req is added to requirements.txt
            if base_name == 'auto-req':
                package = f"auto-req=={version('auto-req')}"
            
            packages = {
                pkg for pkg in packages 
                if not pkg.split('==')[0].split('>=')[0].split('<=')[0] == base_name
            }
            
            if any(op in package for op in ['==', '>=', '<=']):
                clean_package = package
            else:
                try:
                    pkg_version = version(package)
                    clean_package = f"{package}=={pkg_version}"
                except PackageNotFoundError:
                    clean_package = package
            
            packages.add(clean_package)
            self._write_requirements(packages)
            
        except Exception as e:
            print(f"Warning: Could not update requirements: {e}", file=sys.stderr)
